var p = (r, t, i) => {
  if (!t.has(r))
    throw TypeError("Cannot " + i);
};
var e = (r, t, i) => (p(r, t, "read from private field"), i ? i.call(r) : t.get(r)), w = (r, t, i) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, i);
}, g = (r, t, i, s) => (p(r, t, "write to private field"), s ? s.call(r, i) : t.set(r, i), i);
class f {
  constructor(t, i) {
  }
}
const C = 2147483647;
var n, d;
const u = class {
  constructor(t, i, s, h = !0) {
    w(this, n, void 0);
    w(this, d, void 0);
    g(this, n, { width: 0, height: 0 });
    const { el: l, ctx: o } = u.initCanvas(t);
    this.el = l, this.ctx = o, g(this, d, h), this.size = { width: i || window.innerWidth, height: s || window.innerHeight };
  }
  get size() {
    return {
      ...e(this, n)
    };
  }
  set size({ width: t, height: i }) {
    var h;
    if (e(this, n).width === t && e(this, n).height === i)
      return;
    e(this, n).width = t, e(this, n).height = i;
    const s = (h = e(this, d) ? window.devicePixelRatio : 1) != null ? h : 1;
    this.el.width = Math.round(e(this, n).width * s), this.el.height = Math.round(e(this, n).height * s), this.el.style.width = e(this, n).width + "px", this.el.style.height = e(this, n).height + "px", e(this, d) && this.ctx.scale(s, s);
  }
  clear() {
    u.clearCanvas(this.ctx, { ...e(this, n) });
  }
  to(t) {
    t.ctx.drawImage(this.el, 0, 0, e(this, n).width, e(this, n).height);
  }
  handleResize(t) {
    this.size = { width: window.innerWidth, height: window.innerHeight };
  }
  static setCanvasStyle(t, i, s) {
    const h = t.style, { zIndex: l = 0, opacity: o = 1 } = i;
    h.position = "fixed", h.top = "0", h.left = "0", h.zIndex = l.toString(), h.width = (s ? s.width : t.width).toString() + "px", h.height = (s ? s.height : t.height).toString() + "px", o !== 1 && (h.opacity = o.toString()), h.pointerEvents = "none";
  }
  static initCanvas(t) {
    t || (t = document.createElement("canvas"));
    const i = t.getContext("2d");
    return {
      el: t,
      ctx: i
    };
  }
  static createOffscreenCanvas() {
    return new u();
  }
  static clearCanvas(t, i) {
    const { width: s, height: h } = i;
    t.clearRect(0, 0, s, h);
  }
};
let x = u;
n = new WeakMap(), d = new WeakMap();
var a, c;
class y {
  constructor(t, i, s, h = !0, l = !0, o = {
    zIndex: 0,
    opacity: 1
  }) {
    w(this, a, void 0);
    w(this, c, void 0);
    g(this, a, new x(t, i, s, h)), x.setCanvasStyle(e(this, a).el, o, { width: i, height: s }), g(this, c, l ? new x(void 0, i, s, h) : null);
  }
  get size() {
    return e(this, a).size;
  }
  draw(t) {
    var s;
    const i = (s = e(this, c)) != null ? s : e(this, a);
    i.clear(), t(i.ctx, {
      ...i.size
    });
  }
  render() {
    !e(this, c) || (e(this, a).clear(), e(this, c).to(e(this, a)));
  }
  handleResize(t) {
    e(this, a).handleResize(t), e(this, c) && e(this, c).handleResize(t);
  }
  clear() {
    e(this, a).clear(), e(this, c) && e(this, c).clear();
  }
}
a = new WeakMap(), c = new WeakMap();
export {
  y as DrawBoard,
  C as MAX_Z_INDEX,
  f as Theme
};
